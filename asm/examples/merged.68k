*****************************************************************
*	Tiny BASIC for the Motorola MC68000                         *
*                                                               *
*	                                                            *
*                                                               *
* Derived from Palo Alto Tiny BASIC as published in the May 1976*
* issue of Dr. Dobb's Journal. Adapted to the 68000 by:         *
*       Gordon Brandly                                          *
*       Apt. C 8710-97th Ave                                    *
*       Edmonton, Alberta                                       *
*       Canada T6C 2C1                                          *
*                                                               *
*                                                               *
* This version is for MEX68KECB Educational Computer Board I/0. *
*                                                               *
* Copyright (C) 1984 by Gordon Brandly. This program may be	    *
* freely distributed for personal use only. All commercial      *
* rights are reserved.                                          *
*****************************************************************

* Vers. 1.0	1984/7/17	- Original version by Gordon. Brandly
*       1.1 1984/12/9   - Addition of 'S. print term by Marvin Lipford
*       1.2 1985/4/9    - Bug fix in multiply routine by Rick Murray

        OPT FRS,BRS ;forward ref.'s c branches default to short
    
CR      EQU $0d  ;ASCII equates
LF      EQU $0A
TAB     EQU $09
CTRLC   EQU $03
CTRLH   EQU $08
CTRLS   EQU $13
CTRLX   EQU $18

BUFLEN  EQU 80   ;length of keyboard input butter

    ORG $900    ;first free address using Tutor
*	
* Standard jump table. You can change these addresses if you are
* customizing this interpreter for a different environment.
*
START   BRA   CSTART    ; Cold Start entry point
GOWARM  BRA   WSTART    ; Warm Start entry point
GOOOT   BRA   OUTC      ; Jump to character-out routine
COIN    BRA   INC       ; jump to character-in routine
GOAUXO  BRA   AUXOUT    ; Jump to auxiliary-out routine
GOAUXI  BRA   AUXIN     ; Jump to auxiliary-in routine
GOBYE   BRA    BYEBYE   ; Jump to monitor, DOS, etc.
*	
* Modifiable system constants:
TXTBGN DC.L	TXT         ; beginning of program memory
ENDMEM DC.L	$8000       ; end of available memory

* The main interpreter starts here: 
*
CSTART MOVE.L   ENDMEM,A7      ;initialize stack pointer 
        LEA     INITMSG, A6    ;tell who we are
        BSR     PRMESG
        MOVE.L  TXTBGN, TXTUNF ;init. end-of-program pointer 
        MOVE.L  ENDMEM,D0      ;get address of end of memory 
        SUB.L   #2048,D0       ;reserve 2K for the stack
        MOVE.L  D0, STKLMT 
        SUB.L   #108,D0        ;reserve variable area (27 long words) 
        MOVE.L  D0,VARBGN
WSTART  CLR.L    D0             ;Initialize internal variables
        MOVE.L  D0, LOPVAR
        MOVE.L  D0, STKGOS
        MOVE.L  D0, CURRNT     ;current line number pointer - 0 
        MOVE.L  ENDMEM,SP      ;init S.P. again, just in case 
        LEA     ONMSG,A6       ;display "OK"
        BSR     PRMESG
ST3     MOVE.B  #'>',D0        ;Prompt with a t>' and 
        BSR     GETLN          ;read a line.
        BSR     TOUPBUF        ;convert to upper case
        MOVE.L  A0, A4         ;save pointer to end of line 
        LEA     BUFFER, A0     ;point to the beginning of line
        BSR     TSTNUM         ;is there a number there? 
        BSR     IGNBLK         ;skip trailing blanks
        TST     D1             ;does line no. exist? (or nonzero?) 
        BEQ     DIRECT         ;If not, its a direct statement
        CMP.L   ISFEFF,D1      ;see if line no. is <- 16 bits 
        BCC     QHOW           ;if not, we've overflowed 
        MOVE.B  D1,-(A0)       ;store the binary line no. 
        ROR     #8, D1         ;(Kludge to store a word on a 
        MOVE.B  D1,-(A0)       ;possible byte boundary)
        ROL     #8,D1 
        BSR     FNDLN          ;find this line in save area 
        MOVE.L  A1,A5          ;save possible line pointer 
        BNE     ST4            ;if not found, insert
        BSR     ENDNXT         ;find the next line (into A1) 
        MOVE.L  A5,A2          ;pointer to line to be deleted 
        MOVE.L  TXTUNF, A3     ;points to top of save area 
        BSR     MVUP           ;move up to delete
        MOVE.L  A2, TXTUNF     ;update the end pointer
ST4     MOVE.L  A4, D0         ;calculate the length of new line
        SUB.L   A0, D0 
        CMP.L   03,D0          ;is it just a line no. i CR? 
        BEQ     ST3            ;if so, it was just a delete 
        MOVE.L  TXTUNF, A3     ;compute new end
        MOVE.L  A3,A6 
        ADD.L   D0,A3 
        MOVE.L  VARBGN, D0     ;see if there's enough room
        CMP.L   A3, D0 
        BLS     QSORRY         ;If not, say so
        MOVE.L  A3, TXTUNF     ;if so, store new end position 
        MOVE.L  A6,A1          ;points to old unfilled area 
        MOVE.L  A5,A2          ;points to beginning of move area 
        BSR     MVDOWN         ;move things out of the way
        MOVE.L  A0,A1          ;set up to do the insertion
        MOVE.L  A5,A2
        MOVE.L  A4, A3 
        BSR     MVUP           ;do It
        BRA     ST3            ;go back and get another line
*
*******************************************************************
* *** Tables *** DIRECT *** EXEC ***
*
* This section of the code tests a string against a table. When
* a match is found, control is transferred to the section of
* code according to the table.
*
* At 'EXEC', A0 should point to the string, A1 should point to
* the character table, and A2 should point to the execution
* table. At 'DIRECT', A0 should point to the string, A: and
* A2 will be set up to point to TABI and TAB1_1, which are
* the tables of all direct and statement commands.
*
* A '.' in the string will terminate the test and the partial
* match will be considered as a match, e.g. 'P.', 'PR.','PRI.',
* 'PRIN.', or 'PRINT' will all match 'PRINT'.
*
* There are two tables: the character table and the execution
* table. the character table consists of any number of text items.
* Each item is a string of characters with the last character's
* high bit set to one. The execution table holds a 16-bit
* execution addresses that correspond to each entry in the
* character table.
*
* The end of the character table is a 0 byte which corresponds
* to the default routine In the execution table, which is
* executed if none of the other table items are matched.
*
* Character-:matching tables: 
TAB1   DC.B   'LIS',   ('T'+$80)   ;Direct commands
       DC.B   'LOA',   ('D'+$80)
       DC.B   'NE',    ('W'+$80)
       DC.B   'RU',    ('N'+$80)
       DC.B   'SAV',   ('E'+$80)
TAB2   DC.B   'NEX',   ('T'+$80)   ;Direct / statement
       DC.B   'LE',    ('T'+$80)
       DC.B   'I',     ('F'+$80)
       DC.B   'GOT',   ('O'+$80)
       DC.B   'GOSU',  ('B'+$80)
       DC.B   'RETUR', ('N'+$80)
       DC.B   'RE',    ('M'+$80)
       DC.B   'FO',    ('R'+$80)
       DC.B   'INPU',  ('T'+$80)
       DC.B   'PRIN',  ('T'+$80)
       DC.B   'POK',   ('E'+$80)
       DC.B   'STO',   ('P'+$80)
       DC.B   'BY',    ('E'+$80)
       DC.B   'CAL',   ('L'+$80)
       DC.B   0
TAB4   DC.B   'PEE',   ('K'+$80)   ;Functions
       DC.B   'RN',    ('D'+$80)
       DC.B   'AB',    ('S'+$80)
       DC.B   'SIZ',   ('E'+$80)
       DC.B   0
TABS   DC.B   'T',     ('O'+$80)   ;'TO" in "FCR"
       DC.B   0
TAB6   DC.B   'STE',   ('P'+$80)   ;"STEP" in "FOR"
       DC.B   0
TAB8    DC.B    '>',('='+$80)          ;Relational operators
        DC.B    '<',('>'+$80)
        DC.B    ('>'+$80)
        DC.B    ('='+$80)
        DC.B    '<',('='+$80)
        DC.B    ('<'+$80)
        DC.B    0
        DC.B    0      ;<- for aligning on a word boundary

* Execution address tables:
TAB1_1  DC.W    LIST                   ;Direct commands
        DC.W    LOAD
        DC.W    NEW
        DC.W    RUN
        DC.W    SAVE
TAB2_1 DC.W     NEXT                   ;Direct / statement
        DC.W    LET
        DC.W    IF
        DC.W    GOTO
        DC.W    GOSUB
        DC.W    RETURN
        DC.W    REM
        DC.W    FOR
        DC.W    INPUT
        DC.W    PRINT
        DC.W    POKE
        DC.W    STOP
        DC.W    GOBYE
        DC.W    CALL
        DC.W    DEFLT
TAB4_1  DC.W    PEEK                   ;Functions
        DC.W    RND
        DC.W    ABS
        DC.W    SIZE
        DC.W    XP40
TAB5_1  DC.W    FR1                    ;"TO" in "FOR"
        DC.W    QWHAT
TAB6_1  DC.W    FR2                    ;"STEP" in "FOR" 
        DC.W    FR3
TAB8_1  DC.W    XP11   ; >=              ;Relational operators
        DC.W    XP12   ; <>
        DC.W    XP13   ; >
        DC.W    XP15   ; =
        DC.W    XP14   ; <=
        DC.W    XP16   ; <
        DC.W    XP17
*
DIRECT LEA      TAB1,A1
        LEA     TAB1_1,A2
EXEC    BSR     IGNBLK                 ;ignore leading blanks
        MOVE.L A0,A3                   ;save the pointer
        CLR.B   D2                     ;clear match flag
EXLP    MOVE.B  (A0)+,D0             ;get the program character
        MOVE.B  (A1),D1                ;get the table character
        BNE     EXNGO                  ;If end of table,
        MOVE.L A3,A0                   ;restore the text pointer and...
        BRA     EXGO                   ;execute the default.
EXNGO   MOVE.B D0,D3                   ;Else check for period...
        AND.B   D2,D3                  ;and a match.
        CMP.B   #'.',D3
        BEQ     EXGO                   ;if so, execute
         AND.B     #$7F,D1                       ;ignore the table's high bit
         CMP.B     D0,D1                         ;is there a match?
         BEQ       EXMAT
         ADDQ.L    #2,A2                         ;if not, try the next entry
         MOVE.L A3,A0                            ;reset the program pointer
         CLR.B     D2                            ;sorry, no match
EXI      TST.B     (A1)+                         ;get to the end of the entry
         BPL       EX1
         BRA       EXLP                          ;back for more matching
EXMAT    MOVEQ     #-1,D2                        ;we've got a match so far
         TST.B     (A1)+                         ;end of table entry?
         BPL       EXLP                          ;if not, go back for more
ExGo     LEA       0,A3                          ;execute the appropriate routine
         MOVE       (A2),A3
         JMP       (A3)
*
********************************************************************
* What follows is the code to execute direct and statement
* commands. Control is transferred to these points via the command
* table lookup code of 'DIRECT' and 'EXEC' in the last section.
* After the COMMand is executed, control is transferred to other
* sections as follows:
*
* For 'L:ST', 'NEW', and 'STOP': go back to the warm start point.
* For 'RUN': go execute the first stored line if any; else go
* back to the warm start point.
* For 'GOTO' and 'GOSUB': go execute the target line.
* For 'RETURN' and 'NEXT'; go back to saved return line.
* For all others: if 'CURRNT' is 0, go to warm start; else go
* execute next command. (This is done in 'FINISH'.)
*
********************************************************************
*
* "4 NEW *** STOP *** RUN       friends) "" GOTO ***
*
* 'NEW<CR,' sets TXTUNF to point to TXTBGN
*
* ISTOP<CR>s goes back to WSTART
*
* 'RUN<CR>' finds the first stored line, stores its address
* in CURRNT, and starts executing it. Note that only those
* commands in TAB? are legal for a stored program.
*
* There are 3 more entries in 'RUN':
* 'RUt'NXL' finds next line, stores it's address and executes it.
* 'RUNTS1... stores the address of this line and executes it.
* 'RUNSML' continues the execution on same line.
*
* 'GOTO expr<CR>' evaluates the expression, finds the target
* line, and lumps to 'RUNTSL' to do it.
*
NEW      BSR      ENDCHK
         MOVE.L   TXTBGN,TXTUNF          ;set the end pointer

STOP     BSR      ENDCHK
         BRA      WSTART

RUN      BSR      ENDCHK
         MOVE.L   TXTBGN,AC              ;set pointer to beginning
         MOVE.L   A0,CURRNT
RUNNXL  TST.L   CURRNT                 ;executing a program?
        BEQ     WSTART                 ;if not, we've finished a direct stat.
        CLR.L   D1                     ;else find the next line number
        MOVE.L  A0,A1
        BSR     FNDLNP
        BCS     WSTART                 ;if we've fallen off the end, stop

RUNTSL  MOVE.L  Al,CURRNT                       ;set CURRNT to point to the line no. 
        MOVE.L  A1,A0                  ;set the text pointer to
        ADDQ.L  #2,A0                  ;the start of the line text

RUNSML  BSR     CHKIO                  ;see if a control-C was pressed 
        LEA     TAB2,A1                ;find command in TAB2
        LEA     TAB2_1,A2
        BRA     EXEC                   ;and execute it

GOTO    BSR     EXPR                   ;evaluate the following expression
        BSR     ENDCHK                 ;must find end of line
        MOVE.L  D0,D1
        BSR     FNDLN                  ;find the target line
        BNE     QHOW                   ;no such line no.
        BRA     RUNTSL                 ;go do it

*
********************************************************************
*
* *** LIST 0* PRINT ***
*
* LIST has two forms:
* 'LIST<CR>' lists all saved lines
* 'LIST *<CR>I starts listing at the line II
* Control-S pauses the listing, control-C stops it.
*
* PRINT command is 'PRINT              or 'PRINT ....<CR>'
* where '....' is a list of expressions, formats, back-arrows,
* and strings. These Items a separated by commas.
*
* A format is a pound sign followed by a number. It controls
* the number of spaces the value of an expression is going to
* be printed in. It stays effective for the rest of the print
* command unless changed by another format. If no format is
* specified, 11 positions will be used.
*
* A string is quoted in a pair of single- or double-quotes.
*
* An underline (back-arrow) means generate a <CR> without a <LF>
*
* A <CR LF> is generated after the entire list has been printed
* or if the list is empty. If the list ends with a semicolon,
* however, no <CR LF> is generated.
*

LIST    BSR     TSTNUM                 ;see if there's a line no.
        BSR     ENDCHK                 ;if not, we get a zero
        BSR     FNDLN                  ;find this or next line
LS1     BCS     WSTART                 ;warm start if we passed the end
        BSR     PRTLN                  ;print the line
        BSR     CHKIO                  ;check for listing halt request
        BEQ     LS3
        CMP.B   #CTRLS,D0              ;pause the listing?
        BNE    LS3
LS2     BSR    CHKIO           ;if so. wait for another keypress
        BEQ    LS2
LS3     BSR    FNDLNP          ;find the next line
        BRA    LS1

PRINT   MOVE   #11,04          ;D4 - number of print spaces
        BSR    TSTC            ;if null list and ":"
        DC.B   ':',PR2-*
        BSR    CRLF            ;give CR-LF and continue
        BRA    RUNSML          ;execution on the same line
PR2     BSR    TSTC            ;if null list and <CR>
        DC.B   CR,PR0-*
        BSR    CRLF            ;also give CR-LF and
        BRA    RUNNXL          ;execute the next line
PR0     BSR    TSTC            ;else 13 it a format? 
        DC.B   '#',PR1-*
        BSR    EXPR            ;yes, evaluate expression
        MOVE   D0,D4           ;and save it as print width
        BRA    PR3             ;look for more to print
PR1     BSR    TSTC            ;Is character expression? (MRL)
        DC.B   '5',PR4-*
        BSR    EXPR            ;yep. Evaluate expression (MRL)
        BSR    GOOUT           ;print low byte IMRL)
        BRA    PR3             ;look for more. iMRLI
PR4     BSR    QTSTG           ;is it a string?
        BRA    PR8             ;if not, must be an expression
PR3     BSR    TSTC            ;If ",", go find next 
        DC.B   ',',PR6-*
        BSR    FIN             ;in the list.
        BRA    PR0
PR6     BSR    CRLF            ;list ends here
        BRA    FINISH
PR8     MOVE   D4,-(SP)        ;save the width value
        BSR    EXPR            ;evaluate the expression
        MOVE   (SP)+,D4        ;restore the width
        MOVE.L D0,01
        BSR    PRTNUM          ;print its value
        BRA    PR3             ;more to print?

FINISH  BSR    FIN             ;Check end of command
        BRA    QWHAT           ;print "What?" if wrong

*
********************************************************************
*
* ** GOSUB *** 4 RETURN **
*
* 'GOSUB expr:' or 'GOSUB expr<CR>' is like the 'GOTO' command,
* except that the current text pointer, stack pointer, etc. are
* saved so that execution can be continued after the subroutine
* 'RETURN's. In order that 'GOSUB' can be nested (and even
* recursive), the save area must be stacked. The stack pointer
* is saved in 'STKGOS'. The old 'STEWS' is saved on the stack.
* If we are in the rain routine, 'STKGOS' is zero (this was done
* in the initialization section of the interpreter), but we still
* save it as a flag for no further 'RETURN's.
*
* 'RETURN<CR>' undoes everything that 'GOSUB' did, and thus
* returns the execution to the command after the most recent
* 'GOSUB'. If 'STKGOS' is zero, it indicates that we never had
* a 'GOSUB' and is thus an error.
*
GOSUB	BSR     PUSHA           ;save the current 'FOR' parameters  
        BSR     EXPR            ;get line number
        MOVE.L  A0,-(SP)        ;save text pointer
        MOVE.L  DO,D1           
        BSR     FNDLN           ;find the target line
        BNE     AHOW            ;if not there, say "How?"
        MOVE.L  CURRNT,-(SP)    ;found it, save old 'CURRNT'... 
        MOVE.L  STKGOS,-(SP)    ;and 'STKGOS'
        CLR.L   LOPVAR          ;load new values
        MOVE.L  SP,STKGOS       
        BRA     RUNTSL          

RETURN  BSR     ENDCHK          ;there should be just a <CR>
        MOVE.L  STKGOS,D1       ;get old stack pointer
        BEQ     QWHAT           ;if zero, it doesn't exist
        MOVE.L  D1,SP           ;else restore it
        MOVE.L  (SP)+,STKGOS    ;and the old 'STKGOS'
        MOVE.L  (SP)+,CURRNT    ;and the old 'CURRNT'
        MOVE.L  (SP)+,A0        ;and the old text pointer
        BSR     POPA            ;and the old 'FOR' parameters
        BRA     FINISH          ;and we are back home
  
*
********************************************************************
*
* *** FOR *** & NEXT ***
* 'FOR' has two forms:
* 'FOR var-expl TO exp2 STEP expl' and 'FOR var-expl TO exp2'
* The second form means the same thing as the first form with a
* STEP of positive 1. The interpreter will find the variable 'var'
* and set its value to the current value of 'expl'. It also
* evaluates 'exp2' and 'expl' and saves all these together with
* the text pointer, etc. in the 'FOR' save area, which consisits of
* 'LOPVAR', 'LOPINC', 'LOPLMT', 'LOPLN', and 'LOPPT'. If there is
* already something in the save area (indicated by a non-zero
* ILOPVAR'1, then the old save area is saved on the stack before
* the new values are stored. The interpreter will then dig in the
* stack and find out if this same variable was used in another
* currently active 'FOR' loop. If that is the case, then the old
* 'FOR' loop is deactivated. (i.e. purged from the stack)
*
* 'NEXT var' serves as the logical (not necessarily physical) end
* of the 'FOR' loop. The control variable 'var' is checked with
* the 'LOPVAR'. If they are not the same, the interpreter digs in
* the stack to find the right one and purges all those that didn't
* match. Either way, it then adds the 'STEP' to that variable and
* checks the result with against the limit value. If it is within
* the limit, control loops back to the command following the
* 'FOR'. If it's outside the limit, the save area is purged and
* execution continues.
*
FOR     BSR     PUSHA           ;save the old 'FOR' save area
        BSR     SETVAL          ;set the control variable
        MOVE.L  A6,LOPVAR       ;save its address
        LEA     TAB5,A1         ;use 'EXEC' to test for 'TO'
        LEA     TAB5_1,A2 
        BRA     EXEC
FRI     BSR     EXPR          ;evaluate the limit
        MOVE.L  D0, LOPLMT    ;save that
        LEA     TAB6, A1      ;use 'EXEC' to look for the 
        LEA     TAB6_1,A2     ;word 'STEP'
        BRA     EXEC
FR2     BSR     EXPR          ;found it, get the step value
        BRA     FR4
FR3     MOVEQ   #1,D0         ;not found, step defaults to 1
FR4     MOVE.L  D0,LOPINC     ;save that too
FRS     MOVE.L  CURRNT, LOPLN ;save address of current line number 
        MOVE.L  A0, LOPPT     ;and text pointer
        MOVE.L  SP,A6         ;dig into the stack to find 'LOPVAR'
        BRA     FR7
FR6     ADDA.L  #20,A6        ;look at next stack frame
FR7     MOVE.L  (A6),D0       ;is it zero?
        BEQ     FRS           ;if so, we're done
        CMP.L   LOPVAR, D0    ;same as current LOPVAR?
        BNE     FR6           ;nope, look some more
        MOVE.L  SP,A2         ;Else remove 5 long words from... 
        MOVE.L  A6, A1        ;Inside the stack.
        LEA     20, A3
        ADDA.L  A1, A3
        BSR     MVDOWN
        MOVE.L  A3, SP        ;set the SP 5 long words up 
FR8     BRA     FINISH        ;and continue execution

NEXT    BSR     TSTV          ;get address of variable
        BCS     QWHAT         ;if no variable, say "What?' 
        MOVE.L  D0,A1         ;save variable's address
NX0     MOVE.L  LOPVAR, D0    ;If 'LOPVAR' is zero, we never... 
        BEQ     QWHAT         ;had a FOR loop, so say "What?" 
        CMPA.L  D0,A1         ;else we check them
        BEQ     NX3           ;OK, they agree
        BSR     POPA          ;nope, let's see the next frame
        BRA     NX0
NX3     MOVE.L  (A1),D0       ;get control variable's value 
        ADD.L   LOPINC,D0     ;add in loop increment
        BVS     QHOW          ;say "How?" for 32-bit overflow 
        MOVE.L  D0,(A1)       ;save control variable's new value 
        MOVE.L  LOPLMT,D1     ;get loop's limit value
        TST.L   LOPINC
        BPL     NX1           ;branch if loop increment is positive
        EXG     D0, D1 
NX1     CMP.L   D0,D1         ;test against limit
        BLT     NX2           ;branch if outside limit
        MOVE.L  LOPLN, CURRNT ;Within limit, go back to the... 
        MOVE.L  LOPPT, A0     ;saved 'CURRNT' and text pointer.
        BRA     FINISH
NX2     BSR     PCPA          ;purge this loop
        BRA     FINISH

*
********************************************************************
*
* *** REM *** IF *** INPUT *** LET (& DEFLT) ***

* 'REM' can be followed by anything and is ignored by the
* interpreter.
*
* 'IF' is followed by an expression, as a condition and one or
* more commands (including other 'IF's) separated by colons.
* Note that the word 'THEN' is not used. The interpreter evaluates
* the expression. If it is non-zero, execution continues. If it
* is zero, the commands that follow are ignored and execution
* continues on the next line.
*
* 'INPUT' is like the 'PRINT' command, and is followed by a list
* of items. If the item is a string in single or double quotes,
* or is an underline (back arrow), it has the same effect as in
* 'PRINT'. If an item is a variable, this variable name is
* printed out followed by a colon, then the interpreter waits for
* an expression to be typed in. The variable is then set to the
* value of this expression. If the variable is proceeded by a
* string (again in single or double quotes), the string will be
* displayed followed by a colon. The interpreter the waits for an
* expression to be entered and sets the variable equal to the
* expression's value. If the input expression is invalid, the
* interpreter will print "What?", "How?", or "Sorry" and reprint
* the prompt and redo the input. The execution will not terminate
* unless you press control-C. This is handled in 'INPERR'.

* 'LET' is followed by a list of items separated by commas.
* Each item consists of a variable, an equals sign, and an
* expression. The interpreter evaluates the expression and sets
* the variable to that value. The interpreter will also handle
* 'LET' commands without the word 'LET'. This is done by 'DEFLT'.
*
REM    BRA     IF2           ;skip the rest of the line

IF     BSR     EXPR          ;evaluate the expression 
IF1    TST.L   D0            ;is it zero?
       BNE     RUNSML        ;if not, continue
IF2    MOVE.L  A0,A1
       CLR.L   D1
       BSR     FNDSKP        ;if so, skip the rest of the line 
       BCC     RUNTSL        ;and run the next line
       BRA     WSTART        ;if no next line, do a warm start

INPERR MOVE.L STKINP,SP      ;restore the old stack pointer 
       MOVE.L  (SP)+,CURRNT  ;and old 'CURRNT'
       ADDQ.L  #4,SP
       MOVE.L  (SP)+,A0      ;and old text pointer

INPUT  MOVE.L  A0,-(SP)      ;save in case of error 
       BSR     QTSTG         ;is next item a string? 
       BRA     IP2           ;nope
       BSR     TSTV          ;yes, but is it followed by a variable? 
       BCS     IP4           ;if not, branch
       MOVE.L  D0,A2         ;put away the variable's address
       BRA     IP3           ;if so, input to variable 
IP2    MOVE.L  A0, -(SP)     ;save for 'PRTSTG'
       BSR     TSTV          ;must be a variable now 
       BCS     QWHAT         ;"What?" it isn't?
       MOVE.L  D0,A2         ;put away the variable's address
       MOVE.B  (A0),D2       ;get ready for 'PRTSTG'
       CLR.B   D0
       MOVE.B  D0,(A0) 
       MOVE.L  (SP)+,A1 
       BSR     PRTSTG        ;print string as prompt 
       MOVE.B  D2, (A0)      ;restore text
IP3     MOVE.L  A0, -(SP)      ;save in case of error 
        MOVE.L  CURRNT,-(SP)   ;also save 'CURRNT'
        MOVE.L  #-1,CURRNT     ;flag that we are in INPUT 
        MOVE.L SP,STKINP       ;save the stack pointer too 
        MOVE.L  A2,-(SP)       ;save the variable address 
        MOVE.B  #':',D0        ;print a colon first
        BSR     GETLN          ;then get an input line 
        LEA     BUFFER,A0      ;point to the butter
        BSR     EXPR           ;evaluate the input
        MOVE.L  (SP)+,A2       ;restore the variable address 
        MOVE.L  D0,(A2)        ;save value in variable 
        MOVE.L  (SP)+,CURRNT   ;restore old 'CURRNT'
        MOVE.L  (SP)+,A0       ;and the old text pointer 
IP4     ADDQ.L  #4,SP          ;clean up the stack
        BSR     TSTC           ;is the next thing a comma?
        DC.B    ',',IPS-*
        BRA     INPUT          ;yes, more items
IPS     BRA     FINISH

DEFLT   CMPI.B  #CR,(A0)       ;empty line is OK 
        BEQ     LT1            ;else it 13 'LET'

LET     BSR     SETVAL         ;do the assignment
        BSR     TSTC           ;check for more 'LET' items
        DC.B    ',',LT1-* 
        BRA     LET
LT1     BRA     FINISH         ;until we are finished.

*
********************************************************************
*
* *** LOAD *** & SAVE ***
*
* These two commands transfer a program to/from an auxiliary
* device such as a cassette, another computer, etc. The program
* is converted to an easily-stored format: each line starts with
* a colon, the line no. as 4 hex digits, and the rest of the line.
* At the end, a line starting with an '9' sign is sent. This
* format can be read back with a minimum of processing time by
* the 68000.
*
LOAD    MOVE.L TXTBGN, A0      ;set pointer to start of proq. area
        MOVE.B  #CR, D0        ;For a CP/M host, tell it we're ready...
        BSR     GOAUXO          ;by sending a CR to finish PIP command.
LOD1    BSR     GOAUXI         ;look for start of line
        BEQ     LOD1
        CMP.B   #'@',D0        ;end of program?
        BEQ     LODEND
        CMP.B   #';',D0        ;if not, is it start of line?
        BNE     LOD1           ;if not, wait for it
        BSR     GBYTE          ;get first byte of line no.
        MOVE.B  D1,(A0)+       ;store it
        BSR     GBYTE          ;get 2nd bye of line no.
        MOVE.B  D1,(A0)+       ;store that, too
LOD2    BSR     GOAUXI         ;get another text char.
        BEQ     LOD2
        MOVE.B  D0,(A0)+      ;Store It
        CMP.B   #CR, D0        ;Is it the end of the line?
        BNE     LOD2           ;if not, go back for more
        BRA     LOD1           ;if so, start a new line
LODEND MOVE.L A0,TXTUNF      ;set end-of program pointer
       BRA     WSTART        ;back to direct mode

GBYTE  MOVEQ   #1,D2         ;get two hex characters from auxiliary
       CLR     D1            ;and store them as a byte in DI
GBYTE1 BSR     GOAUXI        ;get a char.
       BEQ     GBYTE1
       CMP.B   #'A',D0
       BCS     GBYTE2
       SUBQ.B  #7,D0         ;if greater than 9, adjust
GBYTE2 AND.B   #$F,D0        ;strip ASCII
       LSL.B   #4,D1              ;put nybble into the result
       OR.B    D0,D1
       DBRA    D2,GBYTE1     ;get another char.
       RTS

SAVE   MOVE.L TXTBGN,A0      ;set pointer to start of prog. area
       MOVE.L TXTUNF,A1      ;set pointer to end of prog. area
SAVE1  MOVE.B  #CR,D0        ;send out a CR 6 LF (CP/M likes this)
       BSR     GOAUXO
       MOVE.B  #LF,D0
       BSR     GOAUXO
       CMPA.L  A0,A1         ;are we finished?
       BLS     SAVEND
       MOVE.B  #':',D0       ;if not, start a line
       BSR     GOAUXO
       MOVE.B  (A0)+,D1      ;send first half of line no.
       BSR     PBYTE
       MOVE.B  (A0)+,D1    ;and send 2nd half
       BSR     PBYTE
SAVE2  MOVE.B  (A0)+,D0      ;get a text char.
       CMP.B   #CR,D0        ;is it the end of the line?
       BEQ     SAVE1         ;if so, send CR 6 LF and start new line
       BSR     GOAUXO        ;send it out
       BRA     SAVE2         ;go back for more text
SAVEND MOVE.B  #'@',D0        ;send end-of-program indicator
       BSR     GOAUXO
       MOVE.B  #CR,D0         ;followed by a CR 6 LF
       BSR     GOAUXO
       MOVE.B  #LF,D0
       BSR     GOAUXO
       MOVE.B  #$1A,D0        ;and a control-2 to end the CP/M file
       BSR     GOAUXO
       BRA     WSTART        ;then go do a warm start

PBYTE  MOVEQ   #1,D2         ;send two hex characters from DI's low byte
PBYTE1 ROL.B   #4,D1         ;get the next nybble
       MOVE.B  D1,D0
       AND.B   #$F,D0        ;strip off garbage
       ADD.B   #'0',D0       ;make it into ASCII
       CMP.B   #'9',D0
       BLS     PBYTE2
       ADDQ.B  #7,D0          ;adjust if greater than 9
PBYTE2 BSR     GOAUXO        ;send it out
       DBRA    D2,PBYTE1     ;then send the next nybble
       RTS
*
********************************************************************
*
* *** POKE *** & CALL ***
*
* 'POKE exprl,expr2' stores the byte from 'expr2' into the memory
* address specified by 'exprl'.
*
* 'CALL expr' jumps to the machine language subroutine whose
* starting address is specified by 'expr'. The subroutine can use
* all registers but must leave the stack the way it found it.
* The subroutine returns to the interpreter by executing an RTS.
*
POKE    BSR     EXPR           ;get the memory address
        BSR     TSTC           ;it must be followed by a comma
        DC.B    ',',PKER-*
        MOVE.L  D0,-(SP)       ;save the address
        BSR     EXPR           ;get the byte to be POKE'd
        MOVE.L  (SP)+,A1       ;get the address back
        MOVE.B  D0, (A1)       ;store the byte in memory
        BRA     FINISH
PKER    BRA     QWHAT          ;if no comma, say "What?"

CALL    BSR     EXPR           ;get the subroutine's address
        TST.L   D0             ;make sure we got a valid address
        BEQ     QHOW           ;if not, say "How?"
        MOVE.L  A0,-(SP)       ;save the text pointer
        MOVE.L  D0,A1
        JSR     (A1)           ;jump to the subroutine
        MOVE.L  (SP)+,A0       ;restore the text pointer
        BRA     FINISH
*
********************************************************************
*
* en EXPR ***
*
* 'EXPR' evaluates arithmetical or logical expressions.
* <EXPR>::=<EXPR2>
*         <EXPR2><rel.op.><EXPR2>
* where <rel.op.> is one of the operators in TAB8 and the result
* of these operations is 1 if true and 0 if false.
* <EXPR2>::-(# or -)<EXPR0>(+ or -)<EXPR3>(...
* where () are optional and (... are optional repeats.
* <EXPR3>::=<EXPR4>( .<* or /><EXPR4> )(...
* <EXPR4>::=<variable>
*         <function>
*         (<EXPR>)
* <EXPR> is recursive so that the variable '#' can have an <EXPR>
* as an index, functions can have an <EXPR> as arguments, and
* <EXPR4> can be an <EXPR> in parenthesis.
*
EXPR    BSR     EXPR2
        MOVE.L  D0,-(SP)       ;save <EXPR2> value
        LEA     TAB8,A1        ;look up a relational operator
        LEA     TAB8_1,A2
        BRA     EXEC           ;go do it

XP11    BSR     XP18           ;is it *>"?
        BLT     XPRT0          ;no, return 00-0
        BRA     XPRT1          ;else return Deal
XP12   BSR    XP18             ;is it "<>"?
       BEQ    XPRT0            ;no, return D0=O
       BRA    XPRTI            ;else return D0=1

XP13   BSR    XP18             ;is it ">"?
       BLE    XPRT0            ;no, return D0=0
       BRA    XPRT1            ;else return D0=1

XP14   BSR    XP18             ;is it "<='?
       BGT    XPRT0            ;no, return D0=0
       BRA    XPRT1            ;else return D0=1

XP15   BSR    XP18             ;is it "="?
       BNE    XPRT0            ;if not, return D0=0
       BRA    XPRT1            ;else return D0=1
XP15RT RTS

XP16   BSR    XP18             ;is it "<"?
       BGE    XPRT0            ;if not, return D0-0
       BRA    XPRT1            ;else return D0-1
XP16RT RTS

XPRT0  CLR.L  D0               ;return D0-0 (false)
       RTS

XPRT1  MOVEQ  #1,D0            ;return D0-1 (true)
       RTS

XP17   MOVE.L (SP)+,D0         ;it's not a rel. operator
       RTS                     ;return D0-<EXPR2>

XP18   MOVE.L (SP)+,00         ;reverse the top two stack items
       MOVE.L (SP)+,D1
       MOVE.L D0,-(SP)
       MOVE.L D1,-(SP)
       BSR    EXPR2            ;do second <EXPR2>
       MOVE.L (SP)+,D1
       CMP.L  D0,D1            ;compare with the first result 
       RTS                     ;return the result

EXPR2  BSR    TSTC             ;negative sign?
       DC.B   '-',XP21-*
       CLR.L  D0               ;yes, fake '0-'
       BRA    XP26
XP21   BSR    TSTC             ;positive sign? ignore it
       DC.B   '+',XP22-*
XP22   BSR    EXPR3            ;first <EXPR3>
XP23   BSR    TSTC             ;add?
       DC.B   '+',XP25-*
       MOVE.L D0,-(SP)         ;yes, save the value
       BSR    EXPR3            ;get the second <EXPR3>
XP24   MOVE.L (SP)+,D1
       ADD.L  D1,D0            ;add it to the first <EXPR3>
       BVS    QHOW             ;branch if there's an overflow
       BRA    XP23             ;else go back for more operations
XP25   BSR    TSTC             ;subtract?
       DC.B   '-',XP42-*
XP26   MOVE.L D0,-(SP)         ;yes, save the result of 1st <EXPR3>
       BSR    EXPR3            ;get second <EXPR3>
       NEG.L  D0               ;change its sign
       JMP    XP24             ;and do an addition
EXPR3 BSR    EXPR4        ;get first <EXPR4> 
XP31  BSR    TSTC         ;multiply?
      DC.B   ',',XP34-*
      MOVE.L D0,-(SP)     ;yes, save that first result 
      BSR    EXPR4        ;get second <EXPR4>
      MOVE.L (SP)+,D1
      BSR    MULT32       ;multiply the two
      BRA    XP31         ;then look for more terms 
XP34  BSR    TSTC         ;divide?
      DC.B   '/',XP42-*
      MOVE.L D0,-(SP)     ;save result of 1st <EXPR4> 
      BSR    EXPR4        ;get second <EXPR4>
      MOVE.L (SP)+,D1
      EXG    D0,D1
      BSR    DIV32        ;do the division
      BRA    XP31         ;go back for any more terms

EXPR4 LEA    TAB4,A1      ;find possible function
      LEA    TAB4_1,A2
      BRA    EXEC
XP40  BSR    TSTV         ;nope, not a function 
      BCS    XP41         ;nor a variable
      MOVE.L D0,A1
      CLR.L  D0
      MOVE.L (A1),D0      ;if a variable, return its value in D0 
EXP4RT RTS
XP41  BSR    TSTNUM       ;or is it a number?
      MOVE.L D1,D0
      TST    D2           ;(if not, V of digits will be zero) 
      BNE    EXP4RT       ;if so, return it in D0
PARN  BSR    TSTC         ;else look for ( EXPR )
      DC.B   '(',XP43-*
      BSR    EXPR
      BSR    TSTC
      DC.B   ')',XP43-*
XP42  RTS
XP43  BRA    QWHAT        ;else say "What?"

*
* ===== Test for a valid variable name. Returns Carry-I if not 
*       found, else returns Carry=O and the address of the 
*       variable in D0.

TSTV  BSR    IGNBLK
      CLR.L  D0
      MOVE.B (A0),D0      ;look at the program text
      SUB.B  #'0',D0
      BCS    TSTVRT       ;C=1: not a variable
      BNE    TV1          ;branch if not "s" array
      ADDQ   #1,AO        ;If it is, it should be
      BSR    PARR         ;followed by (EXPR) as its index.
      ADD.L  D0,D0
      BCS    QHOW         ;say "How?" if index is too big
      ADD.L  D0,D0
      BCS    QHOW
      MOVE.L D0,-(SP)     ;save the index
      BSR    SIZE         ;get amount of free memory 
      MOVE.L (SP)+,D1     ;get back the index
      CMP.L  D1,D0        ;see if there's enough memory 
      BSR    QSORRY       ;if not, say "Sorry"




